---
title: "Comprehensive Guide to Learn Computer Science Online"
author: Lane Wagner
date: "2020-11-18"
lastmod: "2022-08-24"
categories: 
  - "computer-science"
images:
  - /img/800/learning-computer-science-online.webp
---

Be careful about deciding the best way to learn to code. Not all paths are equally effective. Self-taught developers and [bootcamp graduates often struggle](/jobs/getting-a-job-after-coding-bootcamp-is-hard/) a lot to find their first coding job. In my experience, it's much easier to get your foot in the door when you spend the time learning the CS basics that so many "crash courses" skip over when trying to get students to dive directly into the deep end of application code.

Skipping CS basics and starting with web servers is like skipping biology 101 to take a three-week "seminar" in cranial surgery. That said, there is also a problem with students spending 4+ years and thousands of dollars when the same computer science education can be acquired online for a fraction of the investment.

Learning computer science is an inexpensive and effective way to start your coding career, and you can do it completely online. You don't have to go to university to get a top-notch CS education. Let's go over all the resources and tips you need to get a job as a software developer, and you can do it without leaving your room.

## How to Get Started - The Short Answer

There are several main topics studied by computer science students in universities around the world. We will consider some of these topics as "mandatory" and others as "elective" or "optional". Take a look at the list below to get an idea. You should study these topics in the order given.

Also, before diving into all the various requirements, I'd like to point out that I recently launched [Boot.dev - a resource designed to teach computer science through coding exercises](https://boot.dev/). If you're interested in a simple hands-on approach be sure to take a look at that, it's even free to audit.

### Study These Computer Science Topics - Required

<div class="tablewrap">

| Subjects                           | Rationale                                                                                                               |
| ---------------------------------- | ----------------------------------------------------------------------------------------------------------------------- |
| Coding                             | You need to learn to code to put computer science concepts into practice                                                |
| Computer Architecture and Hardware | If you don't understand the physical machines your code runs on, you're at a disadvantage.                              |
| Algorithms and Data Structures     | Arguably the most practical application of CS to most day jobs, learn to write fast code.                               |
| CS Math                            | I'd rather teach a mathematician to code than teach a coder math.                                                       |
| Databases                          | Very few applications get away without a data store, you need to know how to use them.                                  |
| Web Development                    | Most jobs in the industry are involved with the web, you need to learn the tools.                                       |
| Graphics Programming               | Almost all users interact with our software graphically, so understanding how that works is incredibly important.       |
| Functional Programming             | Functional programming is useful for learning important concepts like recursion and is growing as a practical paradigm. |
| Computational Theory               | You've gotta learn about the limits to what computers can do theoretically, even if we assume the best hardware.        |

</div>

### Optional - Choose at least 2

<div class="tablewrap">

| Subjects                                     | Rationale                                                                                                                                                 |
| -------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Cryptography                                 | Cryptography is what makes secure communication possible. If you ever plan to work on the web this is important stuff.                                    |
| Networking                                   | While you may not need to set up servers on your own, it's important to know how complex networks are built.                                              |
| Compilers                                    | Compilers allow us to write high-level code that executes on physical machines, a solid understanding of how they work is valuable.                       |
| Distributed Systems                          | With the advance of Docker, Kubernetes, and the cloud, learning to build scalable distributed systems that can communicate and stay in sync is paramount. |
| Operating Systems                            | Operating systems manage all of our code, they have complete control over our execution environments. Get to know them.                                   |
| Artificial Intelligence and Machine Learning | AI and ML are growing more and more each year. There will likely always be jobs in teaching computers to teach themselves.                                |

</div>

These topics cover almost everything that a typical CS student would learn at a university, though you obviously need to make sure you go appropriately deep into each topic. Later in the article, we'll cover each topic in more detail, and supply resources to get you started.

## Feeling Overwhelmed? Don't Be.

A typical computer science undergraduate takes [4 years to complete their degree](/computer-science/compsci-certificate-vs-degree/). Hopefully, this isn't news to you, that's just how college works. Have hope! If you're teaching yourself, you can cut out the fat and speed up the process. If you follow these tips, you'll likely be able to learn the equivalent of a CS major in less than two years, and should be able to get an internship or a first job after just 3-6 months, depending on how much time you're able to practice and study daily.

Keep in mind, getting a job usually requires more than just knowing your stuff. Getting [certificates](/computer-science/compsci-certificate-vs-degree/) and completing real projects along the way gives you something concrete to put on your resume that will fill in for the missing CS degree.

### 1. Watch Lectures on YouTube, not Tutorials

Tutorials and courses should involve coding, and I'll recommend some resources for doing that. Lectures on the other hand are useful for learning concepts that don't necessarily require hands-on experience. You can watch those videos over breakfast or on the train.

### 2. Get Involved in Dev Communities

Do you browse Reddit, Twitter, or Facebook in your free time? Make a small change to your online content consumption and start reading about technology-related content instead, or in addition to what you already consume. Check out this [list of communities](/misc/best-coding-communities/) to make yourself a part of.

### 3. Interview and Get a Job Early (within the first year)

You are teaching yourself online, and the best way to catapult your education is to get an internship or entry-level job _as soon as you are able to_. Depending on the [kind of CS job](/computer-science/highest-paying-computer-science-jobs/) you're interested in, you can start earlier or later, as some require more or less experience.

## Why Learn Computer Science at All?

Many developers do land well-paying programming jobs without computer science degrees, but it can be hard, it often requires luck or friends in the industry, and once they have a job they often stagnate and are unable to participate in seriously innovating and challenging work.

Knowing the first thing about React, Node, and Mongo might be enough to get a low-paying entry-level job, but I've found that so often those developers hit a ceiling on their earning potential and get burned out of using the same tools quickly.

Don't be that developer, or if you are that developer, you can easily go back and learn the fundamentals.

Like myself, you may have been hearing for the past 15 years that "there are more programming jobs than there are candidates to fill them". While still true, _the software engineering career outlook is changing_.

We've recently had an influx of thousands of self-taught developers or Bootcamp grads that are all looking for entry-level jobs, but don't have the fundamental math and CS skills to solve more technically challenging problems. By having a deeper understanding of computational theory and algorithms, you can set yourself apart to land jobs faster and command a higher salary when you get there.

## Required Topics

### 1 - Coding

Coding can be really fun and has a low barrier to entry. The goal here is to get a solid grasp of **one or two** programming languages. I recommend JavaScript, or Python as some of the most well-suited first languages for new developers. Start writing code and have fun with it! There are tons of projects and courses out there that are great for absolute beginners.

![Coding](/img/800/Coding-body-image-.jpg)

#### Resources

* [Boot.dev's Basic Intro to JavaScript](https://boot.dev/courses/learn-javascript/)
* [Edabit JavaScript Challenges](https://edabit.com/challenges/javascript)
* [A Byte of Python](https://python.swaroopch.com/)
* [The Python Tutorial](https://docs.python.org/3/tutorial/)
* [Python for Everybody](https://www.py4e.com/lessons)
* [FreeCodeCamp's Learn JS](https://www.freecodecamp.org/news/learn-javascript-full-course/)

#### Goals

- Understand and write small programs
- Use variables and expressions
- Use conditional statements
- Use iterative structures
- Use list/array structures
- Understand the basic elements of a programming environment including libraries and modules, editors, interpreters, and the command-line
- Use fundamental programming constructs including control structures, functions, keyboard input, classes, and objects

### 2 - Computer Architecture and Hardware

Computer architecture is arguably the most overlooked subject among the bootcamp and self-taught developer community. It's almost impossible to write performant and efficient software without a basic understanding of the hardware it runs on.

Computers are built of various components (hardware) including the CPU, memory, busses, clocks, and the peripheral devices you are familiar with like the mouse and keyboard. All of these components must communicate with each other and provide a necessary service to the user, but as software developers, the most important components for us to understand are memory (RAM) and the processor (CPU).

![Computer Architecture and Hardware](/img/800/Blog-Post-Header.png)

For example, how does a processor know to take the following expression written in JavaScript, `let sum = 5 + 3` and compute the result of 5 plus 3?

Who taught the processor to understand Arabic numerals? Will, in reality, it doesn't, processors only work bitwise, on _binary_ numbers.

Javascript is run by an interpreter (Node.js or the browser) which itself is a compiled program. The interpreter was written in a compiled language, like C, Rust, or Go, but then compiled into raw byte code that the CPU understands. To get a better handle on how computers, you know, *compute* things, writing assembly code can be very helpful.

Assembly is the native language of the processor, and writing a bit of it can help us understand how the CPU processes stuff. Because assembly is so tightly coupled to CPU architecture, the language changes depending on the processor type. I recommend starting in ARM, it has a more elegant syntax than x86 in my opinion.

#### Resources

- eBook: [Computer Organization and Design](https://ict.iitk.ac.in/wp-content/uploads/CS422-Computer-Architecture-ComputerOrganizationAndDesign5thEdition2014.pdf)
- [Binary and Hexadecimal (Khan Academy)](https://www.khanacademy.org/math/algebra-home/alg-intro-to-algebra#algebra-alternate-number-bases)
- [Azeria Labs Writing Arm Assembly](https://azeria-labs.com/writing-arm-assembly-part-1/)

#### Goals

- Convert and understand the differences between number bases like binary, hex, octal, and decimal
- Understand the basics of computer instruction sets and an assembly language (probably ARM)
- Compose low-level programs that interact directly with the operating system
- Have a basic knowledge of how a CPU works

### 3 - Algorithms and Data Structures

The study of algorithms and data structures is the bread and butter of computer science. We must learn about making computer programs fast so that they can delight our users and find meaningful answers quickly.

I'm in complete agreement with the traditional education system that familiarity with common algorithms and data structures is vital to the success of any developer. Understanding these basic problem-solving skills will also benefit you in any aspect of your career and life.

![tsp](/img/800/travelling_salesman_problem.png)

#### Resources
- [Boot.dev's Learn Algorithms course](https://boot.dev/courses/learn-algorithms)
- [Boot.dev's Learn Data Structures course](https://boot.dev/courses/learn-data-structures)
- [Boot.dev's Learn Advanced Algorithms course](https://boot.dev/courses/learn-advanced-algorithms)
- [Data-Structures & Algorithms with JavaScript](https://github.com/GauravWalia19/Free-Algorithms-Books/blob/master/Library/src/JAVASCRIPT/Data-Structures-%26-Algorithms-with-JavaScript.pdf)
- [Steven Skiena's Video Lectures](https://www.youtube.com/watch?v=A2bFN3MyNDA&list=PLOtl7M3yp-DX32N0fVIyvn7ipWKNGmwpp)
- ["Algorithms" book by Dasgupta](https://freecomputerbooks.com/Algorithms.html)

#### Goals

- Understand the basic principles of various software data structures, including their efficiencies and tradeoffs
- Implement and use several data structures in a known programming language
- Brush up on algebra including exponents and logarithms
- Understand Big-O complexity
- Review structures such as stacks, queues, unsorted lists, and sorted lists
- Implement a Binary Search Tree (BST)
- Practice with balanced trees
- Learn about hashing
- Searching and sorting algorithms
- Learn about graphs and how to traverse them

### 4 - CS Math

Computer science, like many sciences, is just applied mathematics. Many software engineers do their best to ignore this fact, and make ignorant claims like, "I've never had to use math while coding". I've always said that I would rather take a math student and teach them to program than take a programmer and teach them to do the math.

Having a solid understanding of the math that makes computer science work will give you a tremendous edge over developers that lean on the academic understanding of their peers to get by.

#### Resources

- [Khan Academy's Linear Algebra](https://www.khanacademy.org/math/linear-algebra/vectors-and-spaces/vectors/v/vector-introduction-linear-algebra)
- [Concrete Mathematics Book](https://www.csie.ntu.edu.tw/~r97002/temp/Concrete%20Mathematics%202e.pdf)
- [Discrete Mathematics - On Open Introduction](http://discrete.openmathbooks.org/pdfs/dmoi-tablet.pdf)
- [Statistics 110: Probability (Stanford)](https://projects.iq.harvard.edu/stat110/home)

#### Goals

- Pigeonhole Principle
- Induction and Strong Induction
- Propositional Logic
- Equivalences and Normal Forms
- Basic Probability
- Conditional Probability
- Bayes Theorem
- Understand systems of linear equations
- Understand basic probability theory
- Diagonalization of a matrix
- Linear transformations

### 5 - Databases

Database knowledge and theory is one of the most practically applicable topics to most engineering jobs. I've never worked at a company where we didn't have multiple databases, and the most successful engineers at the company wee usually the ones who knew a little something about how to use them.

![](/img/800/databases.jpg)

#### Resources

- [W3 Schools SQL Tutorials](https://www.w3schools.com/sql/)
- [ElasticSearch (NoSQL) Tutorials](https://www.tutorialspoint.com/elasticsearch/index.htm)
- eBook: [Database Design and Relational Theory](http://dl.booktolearn.com/ebooks2/computer/databases/9781449328016_database_design_and_relational_theory_890d.pdf)
- [Relational databases and SQL: edX](https://www.edx.org/course/databases-5-sql)
- [SQL Tutorial: Scaler Topics](https://www.scaler.com/topics/sql/)

#### Goals

- Understand the difference between relational and non-relational databases
- Understand the complexity of different lookup operations
- Be able to design effective database schemas for realistic purposes
- Become proficient in using relational, key-value, and document systems
- Understand the basics of transactions and ACID

### 6 - Web Development

This is what most Bootcamp and self-taught developers learn, and unfortunately not much else. As you can probably imagine, the reason web development is taught at bootcamps is that it's the money-maker. The majority of development jobs, especially jobs with a low barrier to entry are web development opportunities. As you dive into various web development resources, try to focus on a single backend language (and maybe a framework), and a single frontend framework, if you choose to learn one at all.

I recommend [learning backend](/backend/become-backend-developer/) APIs using the Go programming language with no framework. I would also advise building a frontend using vanilla JS, as well as another one using Vue.js or React.js. The practice is worthwhile, and don't skip the vanilla javascript! Frameworks are great but they come and go.

#### Resources

- [Learn Go - For Backend](https://boot.dev/courses/learn-golang)
- [The Odin Project - Comprehensive Web Tutorials](https://www.theodinproject.com/)

#### Goals

- Develop modern web applications on both the client-side and server-side
- Assess various client-side and server-side web application frameworks and contrast their differences
- Create an interactive user experience using JavaScript, HTML, and CSS in the browser
- Create a RESTful API that a browser-based frontend application can create, read, update, and delete information from

### 7 - Graphics Programming

From gaming and video editing software to web browsers, graphics programming is a high-performance, rapidly evolving subject within the industry. You'll want to start with a fairly low-level tool like OpenGL so you can understand what most frameworks like [Unity](https://unity.com/) and [Unreal Engine](https://www.unrealengine.com/en-US/) are built upon. Once you've built a few small projects, I'd recommend using a higher-level framework like one of the ones mentioned above, or even a browser-based tool like WebGL to build a simple game.

![](/img/800/video-game-graphics.jpg)

Resources

- [gltut - OpenGL tutorials on GitHub](https://github.com/paroj/gltut)
- Book: 3D Math Primer for Graphics and Game Development
- Book: Real-Time Rendering, Fourth Edition
- Book: Ray Tracing in One Weekend by Peter Shirly

Goals

- Understand why we use GPUs instead of CPUs for graphics rendering
- Understand why OOP can make our lives a lot easier in the context of game development
- Use basic geometry and trigonometry to build beautiful simulations
- Learn about the performance implications of languages that don't give access to memory
- Have fun - this is the creative side of programming

### 8 - Functional Programming

Functional programming concepts and styles are especially important in web development as frontend applications and frameworks are starting to use functional styles to help make codebases easier to maintain. Recursion, the avoidance of side effects, and purely functional data structures are must-know concepts that will make finding a job in the industry that much easier. Even if you never end up working in a purely functional language, the fundamentals of functional programming apply universally to all coding environments.

#### Resources

- Boot.dev's [Learn Functional Programming course](https://boot.dev/courses/learn-functional-programming)
- eBook: [Common Lisp: A Gentle Introduction to Symbolic Computation](http://www.cs.cmu.edu/~dst/LispBook/book.pdf)

#### Goals

- Understand the difference between functional and imperative programming paradigms
- Implement recursive versions of many common algorithms
- Learn about Lisp and how interpreters work, ideally write a basic interpreter
- Learn about the benefits of pure functions

### 9 - Computational Theory

Computational theory, apart from pure math, is one of the most "pure" computer science topics due to its theoretical nature. Alan Turing, who is often called the father of computer science, pioneered many of the theories that we now use to compute the solutions to complex problems. In my opinion, computational theory is the crowning jewel of a CS education, and understanding its concepts truly sets students apart from their competition in the job market.

#### Resources

- eBook: Sipser's [Introduction to the Theory of Computation](https://notendur.hi.is/mae46/Haskolinn/5.%20misseri%20-%20Haust%202018/Formleg%20ma%CC%81l%20og%20reiknanleiki/Introduction%20to%20the%20theory%20of%20computation_third%20edition%20-%20Michael%20Sipser.pdf)
- Dan Gusfield's [Lectures on YouTube](https://www.youtube.com/playlist?list=PLslgisHe5tBM8UTCt1f66oMkpmjCblzkt)
- Online LaTeX Editor: [Overleaf](https://www.overleaf.com/)
- [ADUni.org lectures and resources](http://aduni.org/courses/theory/index.php?view=cw)

#### Goals

- Understand the capabilities and limitations of different computational models
- Learn about formal notation (LaTeX) and how to analyze formal systems.
- Recognize different classes of computational complexity
- Learn about the Halting problem and turning machines
- Study finite automata and how they can be used to model real-world problems
- Understand the limits of computational models and the real-world systems that rely on them

## Optional Topics - Choose at Least 2

### 1 - Cryptography

Cryptography underpins the security of all digital applications. Valuable engineers need an understanding of not only the best security practices but _how_ and _why_ those best practices work. Cryptography can be a math-heavy subject depending on how deep you dive into the material, so it's probably a good idea to brush up on your math basics as you work through crypto material.

![Cryptography](/img/800/1_zSPtMkp70YN9JDhFRaHHXA.jpeg)

#### Resources

- Boot.dev's [Learn Cryptography course](https://boot.dev/courses/learn-cryptography)
- Christof Paar's [Youtube Lectures](https://www.youtube.com/channel/UC1usFRN4LCMcfIV7UjHNuQg)

#### Goals

- Understand crypto primitives like XOR and one-time-pad
- Implement and study symmetric encryption systems
- Understand the revolutionary concepts introduced to the industry by public-key systems
- Learn and implement block and stream ciphers
- Learn about the standard open-source crypto libraries of a language of your choice
- Create and work with digital signatures to send authenticated data securely

### 2 - Networking

Every once in a while, something goes wrong with a company's server connections, and only the most experienced developers are able to deal with the outage. Those developers are more valuable resources, and as a result command higher salaries. An understanding of networking basics is a huge boon to your engineering career.

![Networking](/img/800/4-Types-of-Business-Networking-Opportunities-to-Consider.jpg)

#### Resources

- [Lectures on YouTube](https://www.youtube.com/watch?v=5D67Qy1tPLY&list=PLLFIgriuZPAcCkmSTfcq7oaHcVy3rzEtc), Kurose and Ross 5th Edition
- FreeCodeCamp's [9-Hour Course](https://www.youtube.com/watch?v=qiQR5rTSshw&feature=youtu.be)

#### Goals

- Fundamental parts of the Internet
- Layered network model
- Domain Name Services (DNS)
- Networking APIs for application developers
- Common network diagnostic tools
- Network performance - throughput, delay, and packet loss
- TCP - Reliability & Congestion Control
- IPv4/IPv6 Addressing / Routing
- Network address translation
- Routing in fixed and ad-hoc wireless networks
- Basic Network Security - Botnets, DoS/DDoS, Viruses, and Worms

### 3 - Compilers

While many popular programming languages like JavaScript and Python are interpreted, many are compiled directly to machine code.

![Compilers](/img/800/compileProcess.jpg)

#### Resources

- eBook: [Compilers: Principles, Techniques and Tools](http://ce.sharif.edu/courses/94-95/1/ce414-2/resources/root/Text%20Books/Compiler%20Design/Alfred%20V.%20Aho,%20Monica%20S.%20Lam,%20Ravi%20Sethi,%20Jeffrey%20D.%20Ullman-Compilers%20-%20Principles,%20Techniques,%20and%20Tools-Pearson_Addison%20Wesley%20(2006).pdf)
- [Let's Build a Compiler Tutorial](https://compilers.iecc.com/crenshaw/)

#### Goals

- Theory of Languages, Grammars, and Machines
- Scanning and Lexical analysis
- Parsing and interpreting
- Interpreting
- Machine Code
- Code Generation
- Storage and symbol management
- Write your own toy compiler from scratch

### 4 - Distributed Systems

The internet has become so unbelievably huge, that very few popular services online can get away with running their systems on a single machine. Previously companies purchase larger and more powerful machines, but Google was one of the pioneers of writing smarter software that can simply leverage the power of many smaller and cheaper machines.

Distributed systems is the study of programs that can efficiently take advantage of hardware wired together over a network, and it's become more relevant all the time.

![Distributed Systems](/img/800/1_tYxWuyksovxA1Thu8PggPQ.jpeg)

#### Resources

- Boot.dev's [Learn Go course](https://boot.dev/courses/learn-golang)
- [Dixie State's Chord Assignment](http://cit.dixie.edu/cs/3410/asst_chord.php)
- [Google's BigTable Research Paper - Read and take notes!](https://storage.googleapis.com/pub-tools-public-publication-data/pdf/68a74a85e1662fe02ff3967497f31fda7f32225c.pdf)
- [Understanding Paxos](https://understandingpaxos.wordpress.com/)

#### Goals

- Differentiate the approaches and solutions to distributed systems implemented by real-world projects (Kubernetes, ElasticSearch, Kafka, etc)
- Design and implement programs that use multiple computers across a network connection
- Learn to use Go for its concurrency patterns, and understand how that helps with the implementation of distributed systems

### 5 - Operating Systems

It's hard to write good software without understanding the software that your software runs on. Just like an understanding of CPU architecture, a good knowledge of how operating systems work will make you a valuable asset to any organization. Most developers only have a cursory knowledge of how Linux operates, and if you deploy on Linux like most of the world, your expertise will be well-rewarded.

![Operating Systems](/img/800/img_5b68e80f77e33.png)

#### Resources

- [Dixie State's Sharks and Divers Exercise](http://cit.dixie.edu/cs/3400/asst_sharks.php)
- eBook: [Operating System Concepts](https://github.com/rangaeeeee/books-os/blob/master/Operating%20System%20Concepts%20-%209th%20Edition.pdf)
- Learn a systems language like Rust: [Tour of Rust](https://tourofrust.com/)

#### Goals

- Understand and interact with the major components of an operating system
- Analyze the tradeoffs between competing goals in a system's software, including safety, performance, convenience, and ease of future maintenance
- Assess and criticize the design of modern and historical operating systems
- Understand boot sequences
- Learn the basic Unix commands and become familiar with using advanced command-line
- Learn about the Linux kernel

### 6 - Artificial Intelligence and Machine Learning

While AI and ML used to be fairly niche fields, they are becoming more and more important as companies are turning to big data to answer long-standing marketing and product problems. If you have any interest at all I would highly recommend at least taking a look at the basics of some of the open-source frameworks like Tensorflow and Keras.

#### Resources

- [Artificial Intelligence, a Modern Approach](https://github.com/yanshengjia/ml-road/blob/master/resources/Artificial%20Intelligence%20-%20A%20Modern%20Approach%20(3rd%20Edition).pdf)
- [Keras Tutorials](https://keras.io/guides/)

#### Goals

- Classical AI search algorithms: uninformed search, informed search, local search
- Important AI concepts like [heuristics](/computer-science/examples-of-heuristics-in-computer-science/) and greedy algorithms
- Propositional and first-order logic
- Probability and probabilistic reasoning
- Machine-learning basics and neural networks using a Keras
- Design problem definitions suitable for use in search algorithms
- Implement and use search algorithms,
- Design and implement propositional logic to solve problems
- Design and implement Bayesian networks to solve problems

## Good Luck!

I wish you the best on your CS journey! Computer science and programming have changed my life for the better. I now have a comfortable salary, a job I enjoy, and I get to meet and work with the most interesting people. Let me know if this guide has helped you and how I can improve it!
