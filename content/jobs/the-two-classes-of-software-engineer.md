---
title: "The Two Classes of Software Engineer"
date: "2021-03-05"
categories: 
  - "computer-science"
  - "jobs"
tags: 
  - "sharing"
---

"Software engineer" has become a ubiquitous term for people who write, deploy, architect, or sometimes even simply test code. In reality, I think there are two classes of "software engineers"; those who understand computer science well enough to do challenging, innovative work, and those who just get by because they’re familiar with a few high-level tools. The laziness with which the tech industry has adopted the term "software engineer" has made it harder for us to distinguish between the two.

For the sake of this article, I'm going to refer to those who've taken the time to study in-depth as "_computer scientists_", and those who skipped the boring stuff to learn how to deploy a React portfolio as "_developers_". Keep in mind I just need some words to work with, there's nothing wrong with the term "developer" and there's nothing magic about the title "computer scientist".

_I won't be talking about the differences in job titles among software engineers. If that's what you're here for check out [this other article on how much money different kinds of engineers make](https://qvault.io/2020/12/09/highest-paying-computer-science-jobs/)._

## It isn't binary, there's obviously a spectrum of skill

Before anyone gets too upset, let me acknowledge that the technical skill level of all software engineers could be divided into as many classes as there are engineers in existence. I'm trying to point out that there seems to be a _great divide_ between those who have taken the time to learn algorithms, data structures, and higher maths, and those who took an 8-week crash course in web development.

## Stop gatekeeping

![](/img/i-am-the-gatekeeper-41079851.jpg)

Sorry, that's not my intention, and I apologize if I'm doing a poor job of expressing my thoughts.

I think the divide is primarily a result of a simple anecdotal observation I keep making: **After engineers find a job they like, they stop learning the hard stuff.** Many of us browse Hacker News, a coding-related subreddit, or follow tech topics on Twitter. While better than nothing, there's a big difference in value between brushing up on algorithms and experimenting with a hot new web framework.

My goal is to articulate the importance of _continuing education_, even after getting that first great job. It doesn't matter if you got your start by attending college, going to a boot camp, or taking online courses, you can become a "computer scientist" - there's no reason to settle as a "developer".

I also want to point out that I don't think the distinction between the two classes lies simply in a gap of knowledge. Being a "_computer scientist_" is more about how you approach and embrace _learning_ and less about what you know _today_. You'll never know all there is to know about an industry as massive as the software industry, but the way you go about learning (or not learning) is what will make you successful.

## But why? I can make six figures without inverting binary trees

It's true that both kinds of software engineers earn similar salaries in their early careers (see [here](https://www.coursereport.com/2020-guide-to-coding-bootcamps-by-course-report.pdf) and [here](https://www.naceweb.org/job-market/compensation/computer-science-grads-projected-to-be-top-paid-in-major/)). In fact, often when people take the university route (I don't always recommend that these days) to learn CS, they have a hard time finding their first job because they never became familiar with modern tools and technologies. Maybe they didn't even learn how to use Git. The difference is that people that started on a "computer science" path will have an easier time learning React, Django, Rails, you name it. On the other hand, those that took a "developer" short-cut will have a harder time figuring out how to scale a moderately complex system if they don't understand Big O.

In other words, it's easier to learn the fundamentals and _then_ the high-level tools, rather than the high-level tools and _then_ the fundamentals. If you did it backwards don't sweat it! The important thing is simply to identify gaps in your knowledge and fill them as you have time.

Over time, and often as soon as the first year of employment, "computer scientists" tend to move towards more fulfilling and well-compensated work, whether that’s well-funded open-source projects, technical leadership, or mission-critical commercial systems. "Developers" tend to continue doing what they've always done, learn a new framework, use an ORM to make simple database queries, or render information in a browser using a tool someone else made.

## Demand won't always be higher than supply

Currently, the number of people needed in software engineering is still [rapidly increasing](http://econdataus.com/claim400k.htm), but (anecdotally, and if anyone has good data on this please let me know) it seems when I talk with entry-level engineers that they're having an increasingly hard time landing a _first job_. With greater competition at the junior levels, it seems more and more apparent that "get-rich-quick" paths [don't often produce the best results](https://qvault.io/2020/11/19/getting-a-job-after-coding-bootcamp-is-hard/).

If you're still struggling to find your first job, are wanting to take your career up a level, or you're simply looking for more job security, taking the time to learn more advanced and specialized subjects is the best path.

## How can I become a "computer scientist"?

"Computer scientists" find ways to learn CS in-depth, whether through conventional means like taking classes at a local university or by taking the initiative to relentlessly self-teach online. "Developers" tend to exist on the surface understanding, preferring to learn specific languages, frameworks, and technologies rather than their underpinnings. "Developers" only pick up new skills when they feel the fads of the time are changing.

If you seek deeper technical fulfillment, don't settle for writing CRUD applications and API calls. Don't be afraid to watch lectures on YouTube, take some challenging CS courses, or start a for-fun project that will require more technical prowess than you're used to. If you're interested in learning CS online, check out my other post, "[A Comprehensive Guide to Learn Computer Science Online](https://qvault.io/2020/11/18/comprehensive-guide-to-learn-computer-science-online/)".

If you're worried about not being able to prove your knowledge if you're just learning in an unaccredited way online, look into [CS certifications](https://qvault.io/2020/12/15/guide-to-certificate-in-computer-science/).
